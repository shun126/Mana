/*!
mana (compiler)

@author	Shun Moriya
@date	2003-
*/

#include "Main.h"
#include "CodeGenerator.h"
#include "ErrorHandler.h"
#include "Lexer.h"
#include "Path.h"
#include "ParsingDriver.h"
#include "Version.h"

#include "../runner/Mana.h"

#include <ctime>
#include <vector>

namespace
{
	char mInputFilename[_MAX_PATH];
	char mOutputFilename[_MAX_PATH];
	bool mExecute;
	bool mDebug;
	bool mRelease;

	std::ofstream mPublicTypeDeclStream;
	std::vector<std::string> mForcedIncludeFiles;
}

namespace mana
{
	const char* GetInputFilename()
	{
		return mInputFilename;
	}

	const char* GetOutputFilename()
	{
		return mOutputFilename;
	}

	const char* GetTargetFilename()
	{
		return mOutputFilename[0] != '\0' ? mOutputFilename : mInputFilename;
	}

	std::ofstream& GetPublicTypeDeclStream()
	{
		return mPublicTypeDeclStream;
	}

	static void Dump(const std::shared_ptr<ParsingDriver>& parser)
	{
		char drive[_MAX_DRIVE];
		char dir[_MAX_DIR];
		char fileName[_MAX_FNAME];
		char ext[_MAX_EXT];
		char path[_MAX_PATH];
		splitpath(mInputFilename, drive, sizeof(drive), dir, sizeof(dir), fileName, sizeof(fileName), ext, sizeof(ext));
		makepath(path, sizeof(path), drive, dir, fileName, ".md");

		std::ofstream log(path);
		if (log.is_open())
		{
			if (parser->GetSymbolFactory())
			{
				log << "# Symbol Table\n";
				parser->GetSymbolFactory()->Dump(log);
				log << "\n";
			}
			if (parser->GetRootSyntaxNode())
			{
				log << "# Syntax Node\n";
				parser->GetRootSyntaxNode()->Dump(log);
			}
			if (parser->GetCodeGenerator())
			{
				log << "# Code\n";
				log << "```\n";
				parser->GetCodeGenerator()->Dump(log);
				log << "```\n";
			}
		}
	}

	static bool GenerateBinary(OutputStream& stream, const std::shared_ptr<ParsingDriver>& parser)
	{
		FileHeader header = {};
		memcpy(&header.mHeader, Signature, sizeof(header.mHeader));
		header.mMajorVersion = MajorVersion;
		header.mMinorVersion = MinorVersion;

		if (IsBigEndian())
			header.mFlag |= (1 << FileHeader::Flag::BigEndian);
#if UINTPTR_MAX == UINT64_MAX
		header.mFlag |= (1 << FileHeader::Flag::Is64Bit);
#endif
		const size_t numberOfActors = parser->GetSymbolFactory()->GetNumberOfActors();
		if (std::numeric_limits<uint32_t>::max() < numberOfActors)
			throw std::overflow_error("Too many actors defined");
		header.mNumberOfActors = static_cast<uint32_t>(numberOfActors);
		header.mSizeOfConstantPool = parser->GetDataBuffer()->GetSize();
		header.mSizeOfInstructionPool = parser->GetCodeBuffer()->GetSize();
		header.mSizeOfStaticMemory = parser->GetSymbolFactory()->GetStaticMemoryAddress();
		header.mSizeOfGlobalMemory = parser->GetSymbolFactory()->GetGlobalMemoryAddress();
		header.mRandomSeedNumber = static_cast<uint32_t>(time(nullptr));

		stream.PushData(&header, sizeof(header));

		if (!parser->GetSymbolFactory()->GenerateActorInformation(stream))
		{
			return false;
		}

		parser->GetDataBuffer()->Write(stream);
		parser->GetCodeBuffer()->Write(stream);

		 return true;
	}

	static bool Execute(const std::shared_ptr<const void>& program)
	{
		std::shared_ptr<VM> vm = std::make_shared<VM>();
		vm->LoadPlugins(".");
		vm->LoadProgram(program);
		while (vm->Run())
			;
		return true;
	}

	int Execute(const std::string& path)
	{
		std::shared_ptr<VM> vm = std::make_shared<VM>();
		vm->LoadPlugins(".");
		vm->LoadProgram(path);
		while (vm->Run())
			;
		return 0;
	}

	int Generate()
	{
		int result = 0;

		try
		{
			std::shared_ptr<ParsingDriver> parser = std::make_shared<ParsingDriver>();
			if (parser == nullptr)
				throw std::bad_alloc();

			if (lexer::Initialize(parser, mInputFilename))
			{
				bool forceIncludeResult = true;
				for (auto it = mForcedIncludeFiles.rbegin(); it != mForcedIncludeFiles.rend(); ++it)
				{
					if (!lexer::Open(*it, false))
					{
						forceIncludeResult = false;
						break;
					}
				}

				if (forceIncludeResult)
				{
					result = parser->Parse() != 0 || yynerrs != 0;
				}
				else
				{
					result = 1;
				}

				if (mPublicTypeDeclStream.is_open())
				{
					if (result == 0)
					{
						mPublicTypeDeclStream << "/*\n";
						mPublicTypeDeclStream << " * This file was automatically generated based on '" << mInputFilename << "'.\n";
						mPublicTypeDeclStream << " * Do not edit this file, as any changes will be overwritten.\n";
						mPublicTypeDeclStream << " */\n";
						mPublicTypeDeclStream << "#pragma once\n";
						mPublicTypeDeclStream << "#include <cstdint>\n\n";
						mPublicTypeDeclStream << "namespace mana\n{\n";
						parser->GetSymbolFactory()->WritePublicTypeDecl(mPublicTypeDeclStream);
						mPublicTypeDeclStream << "}\n";
					}
					mPublicTypeDeclStream.close();
				}

				if (mDebug)
				{
					Dump(parser);
				}

				parser->GetSymbolFactory()->CheckUndefine();

				if (result == 0)
				{
					OutputStream stream;
					if (GenerateBinary(stream, parser))
					{
						if (mOutputFilename[0] != '\0')
						{
							stream.Save(mOutputFilename);
						}
						else
						{
							Execute(stream.MakeShared());
						}
					}
				}
				else
				{
					if (mOutputFilename[0] != '\0')
					{
						std::remove(mOutputFilename);
					}
				}
			}
		}
		catch (const std::exception& e)
		{
			mana::Fatal(e.what());
		}

		lexer::Finalize();

		return result;
	}

	static void PrintTitle()
	{
		printf("mana %s.%s (%04d-%02d-%02d)\n",
			mana::build::MajorVersion, mana::build::MinorVersion,
			mana::build::Year, mana::build::Month, mana::build::Day);
	}

	static void PrintCopyright()
	{
		printf("mana - Copyright (C) 2002-%04d Shun Moriya\n", mana::build::Year);
	}

	static void PrintUsage()
	{
		std::cout << "usage:mana [switch] infile\n";
		std::cout << "            -o filename     specify output binary file name\n";
		std::cout << "            -t dirname      specify program header directory name\n";
		std::cout << "            -I filename     force include file (can be specified multiple times)\n";
		std::cout << "            --execute       read infile as a binary file and execute it\n";
		std::cout << "            --help          print this message\n";
		std::cout << "            --copyright     print copyright holder\n";
		std::cout << "            --version       print the version\n";
		std::cout << "\n";
		std::cout << "Report bugs to https://github.com/shun126/Mana/issues\n";
	}

	static bool ParseArguments(int argc, char* argv[])
	{
		if (argc < 2)
		{
			std::cerr << "No input files\n";
			return false;
		}
		else
		{
			char publicTypeDeclPath[_MAX_PATH];
			publicTypeDeclPath[0] = '\0';

			bool generatePublicTypeDeclPathRequested = false;
			bool generateOutputBinaryPathRequested = false;

			mInputFilename[0] = '\0';
			mOutputFilename[0] = '\0';
			mExecute = false;
			mDebug = false;
			mRelease = false;
			mForcedIncludeFiles.clear();

			for (int cmdcnt = 1; cmdcnt < argc; cmdcnt++)
			{
				char* cmdptr = argv[cmdcnt];
				if (*cmdptr == '-')
				{
					cmdptr++;
					switch (*cmdptr)
					{
					case 'o':
						if (cmdcnt + 1 < argc && *argv[cmdcnt + 1] != '-')
						{
							cmdcnt++;
							strcpy(mOutputFilename, sizeof(mOutputFilename), argv[cmdcnt]);
						}
						else
						{
							generateOutputBinaryPathRequested = true;
						}
						break;

					case 't':
						if (cmdcnt + 1 < argc && *argv[cmdcnt + 1] != '-')
						{
							cmdcnt++;
							strcpy(publicTypeDeclPath, sizeof(publicTypeDeclPath), argv[cmdcnt]);
						}
						else
						{
							generatePublicTypeDeclPathRequested = true;
						}
						break;

					case 'I':
					{
						if (cmdcnt + 1 >= argc)
						{
							std::cerr << "missing include file for -I\n";
							return false;
						}
						cmdcnt++;
						mForcedIncludeFiles.emplace_back(argv[cmdcnt]);
						break;
					}

					case '-':
						cmdptr++;
						if (strcmp(cmdptr, "execute") == 0)
						{
							mExecute = true;
							break;
						}
						if (strcmp(cmdptr, "copyright") == 0)
						{
							PrintCopyright();
							return false;
						}
						if (strcmp(cmdptr, "version") == 0)
						{
							PrintTitle();
							return false;
						}
						if (strcmp(cmdptr, "help") == 0)
						{
							PrintUsage();
							return false;
						}
						if (strcmp(cmdptr, "debug") == 0)
						{
							mDebug = true;
							break;
						}
						if (strcmp(cmdptr, "release") == 0)
						{
							mRelease = true;
							break;
						}
						//[[fallthrough]]
					default:
						std::cerr << "unrecognized option\n";
						return false;
					}
				}
				else if (mInputFilename[0] == '\0')
				{
					strcpy(mInputFilename, sizeof(mInputFilename), cmdptr);
				}
				else
				{
					std::cerr << "unrecognized option\n";
					return false;
				}
			}

			// check
			{
				char drive[_MAX_DRIVE];
				char dir[_MAX_DIR];
				char fileName[_MAX_FNAME];
				char ext[_MAX_EXT];
				splitpath(mInputFilename, drive, sizeof(drive), dir, sizeof(dir), fileName, sizeof(fileName), ext, sizeof(ext));

				if (generatePublicTypeDeclPathRequested)
				{
					makepath(publicTypeDeclPath, sizeof(publicTypeDeclPath), drive, dir, fileName, ".h");
				}
				if (generateOutputBinaryPathRequested)
				{
					makepath(mOutputFilename, sizeof(mOutputFilename), drive, dir, fileName, ".mx");
				}

				// output global types
				if (publicTypeDeclPath[0] != '\0')
				{
					mPublicTypeDeclStream.open(publicTypeDeclPath, std::ios::out);
					if (!mPublicTypeDeclStream.is_open())
					{
						std::cerr << "'" << publicTypeDeclPath << "' open failed.\n";
						return false;
					}
				}
			}

			return true;
		}
	}
}

int main(int argc, char* argv[])
{
	int result = 0;

#if MANA_TARGET_WINDOWS && MANA_BUILD_TARGET < MANA_BUILD_RELEASE
	_CrtMemState stOldMemState;
	_CrtMemState stNewMemState;
	_CrtMemState stDiffMemState;
	_CrtMemCheckpoint(&stOldMemState);

	/*
	 * メモリリーク番号が分かる場合は
	 * _CrtSetBreakAlloc(メモリリーク番号);
	 * で指定すると調べる事ができます
	 */
	//_CrtSetBreakAlloc(423);
#endif

	if (mana::ParseArguments(argc, argv))
	{
		if (mExecute)
			result = mana::Execute(mInputFilename);
		else
			result = mana::Generate();
	}

#if MANA_TARGET_WINDOWS && MANA_BUILD_TARGET < MANA_BUILD_RELEASE
	_CrtMemCheckpoint(&stNewMemState);
	if (_CrtMemDifference(&stDiffMemState, &stOldMemState, &stNewMemState))
	{
		_RPT0(_CRT_WARN, "Memory leaked!\n\n");
		_CrtMemDumpStatistics(&stDiffMemState);
		_CrtDumpMemoryLeaks();
	}
#endif

	return result;
}
