# 第３章 基礎を学ぼう
## プログラムの書き方
プログラムの作成は残念ながらアクターの名前に漢字コードを利用することが出来ません。表の文字セットを用いてください。

### 表2-1 Mana文字セット
- | 文字
---------- | ---------- 
小文字      | abcdefghijklmnopqrstuvwxyz
大文字      | ABCDEFGHIJKLMNOPQRSTUVWXYZ
数字      | 0123456789
記号      | ! @ # $ % ^ & | ( ) { } [ ] = < > , . + - / ? ‘ “ : ;
表示されない文字      | スペース、タブ、改行
	
Manaのプログラムソース(以下ソース)は、基本的には自由形式で記述できます。特別な位置を除いて、任意に空白文字と呼ばれるスペース、タブ、または改行等を入れることが可能です。したがって改行だけの行も使用可能です。 空白文字を入れられる位置には、注釈を記述できます。注釈はコンパイル処理で無視されます。注釈には２つの記述例があり、記述例/から記述例/までの内容は注釈になります。注釈内には改行も含まれます。もう一つの形式では記号例//から行末までが注釈となります。次の例2-2を参考にして下さい。

### 例2-2 注釈の記述例

```
/* 注釈の記述 */
// 注釈の記述
```
## 型と数値
コンピュータで処理されるデータは、定数と変数に大別できます。定数は内容が変化しないものを、変数は逆に内容が変化するものを意味します。これらには型があります。また、変数には参照の有効範囲や寿命などの属性があります。 数値は、整数と実数に分類でき、それぞれサイズの異なる型が存在します。異なる型の間では型の変換が必要です。

## 定数
定数とは変更されない値の事をさします。定数の定義は非常に簡単です。

### 表2-2　定数の書き方

```
define PI 3.14;
define MyHeight 170;
define MyName “Shun”;
```
これでPIは3.14である事やMyHeightは170である事が定義されました。整数定数は通常の10進数以外にも16進数や2進数を用いることができます。

*2進数・16進数 私たちは普段１０進数で生活しています。お金は10で繰り上がるので10進数。他に1ダースは12個なので12進数、1日は24時間で繰り上がるので24進数、1時間は60分で繰り上がるので60進数と言えます。 つまり、進数とはその数でケタが繰り上がる数の数え方と言えます。

### 表2-4 2進数、10進数、16進数
2進数 | 10進数 | 16進数
---------- | ---------- | ------ 
0b0_0000      | 0       | 0x00 
0b0_0001      | 1       | 0x01 
0b0_0010      | 2       | 0x02 
0b0_0011      | 3       | 0x03 
0b0_0100      | 4       | 0x04 
0b0_0101      | 5       | 0x05 
0b0_0110      | 6       | 0x06 
0b0_0111      | 7       | 0x07 
0b0_1000      | 8       | 0x08 
0b0_1001      | 9       | 0x09 
0b0_1010      | 10       | 0x0a 
0b0_1011      | 11       | 0x0b 
0b0_1100      | 12       | 0x0c 
0b0_1101      | 13       | 0x0d 
0b0_1110      | 14       | 0x0e 
0b0_1111      | 15       | 0x0f 
0b1_0000      | 16       | 0x10 

2進数の場合は先頭に0bを付け、16進数の場合は先頭に0xを付けます。例を挙げると、0b1100と0xcはともに12を指しています。

## 型と変数
Manaで使用できるデータ型は意図的に原始型のみのサポートとなっています。原始型とはbyte、short、bool、int、float、stringのことを差します。

### 表2-3 データ型

名称 | バイト数 | 範囲
---------- | ---------- | ------ 
byte      | 1       | -128 ～ 127 
short      | 2       | -32768 ～ 32767 
bool      | 1       | true または false
int      | 4       | -2147483648 ～ 2147483647 
float      | 4       | 実数 
string      | 4       | 文字列 

変数を使用するためには、使用前に宣言または定義の必要があります。宣言は、変数の型や属性をコンパイラに通知します。定義では、変数領域が確保されます。宣言は定義をかねる場合もあります。また宣言や定義の記述位置には特に制限は無く、参照時に定義することも可能です。 変数の宣言はglobalとactor、localの三種類があります。global変数はメモリカード等の外部記憶に保存され、ゲーム中どのアクターでも参照することができます。actor変数はactor内で共有できる変数です。local変数はブロック内のみ参照できる変数です。

### 表2-4 変数の定義方法

```
int global;
actor Girl
{
    int instance;

    action init
    {
        int local;

        instance = 12;
        global = 100;
    }

    action sleep
    {
        local = 1;        // NG: スコープ範囲外なのでlocalは参照できない
        instance = 13;    // OK
    }
}

actor Boy
{
    action init
    {
        global = 0;      // OK
        instance = 0;    // NG: スコープ範囲外なのでlocalは参照できない
    }
}
```
*注）表2-4では分かりやすくする為、宣言内にブロックを書いています。

## 演算子
Manaは算術演算子、論理演算子、関係演算子を使用することが出来ます。

### 算術演算子
算術演算子は加算や減算などの四則演算と剰余計算です。

- | 記号
---------- | ----------
加算      | +
減算      | -
乗算      | *
除算      | /
剰余      | %

### 論理演算子
論理演算子はあまり聞きなれない計算方法ですが、論理否定、論理積、論理和、そして排他的論理和の四種類です。表に示したこれらの演算の値は１00や２56などの数値ではなく、真(値は1)偽(値は0)といった値を使います。

- | 記号
---------- | ----------
論理否定      | !
１の補数      | ~
論理積      | &
論理和      | |
排他的論理和      | ^

### 論理演算子の計算
論理否定(not)は論理を反転させます。論理積(and)は両辺の論理が真の場合のみ結果が真になります。論理和(or)はどちらか片方の辺が真、もしくは両辺が真の場合に真になります。排他的論理和(eor)はどちらか片方の辺が真の場合のみ真になります。

式 | 結果
---------- | ----------
!true      | false
!false      | true
false & false      | false
false & true      | false
true & false      | false
true & true      | true
false | false      | false
false | true      | true
true | false      | true
true | true      | true
false ^ false      | true
false ^ true      | true
true ^ false      | true
true ^ true      | false

### 関係演算子
関係演算子は、二つの演算項を比較し論理値を返します。

- | 記号
---------- | ----------
等しければtrue      | ==
等しくなければtrue      | !=
左辺が右辺よりも小さければtrue      | <
左辺が右辺以下であればtrue      | <=
左辺が右辺よりも大きければtrue      | >
左辺が右辺以上であればtrue      | >=

## 演算子の優先順位
演算子の優先順位は以下のとおりです。

演算子 | 意味 | 結合規則
---------- | ---------- | ------ 
++, --      | 後置インクリメント・デクリメント       | 
++, --      | 前置インクリメント・デクリメント       | 
@, &      | 間接(参照)、アドレス       | 
+, -      | 正符号、負符号       | 
!, ~      | 論理否定(NOT)、ビットごとの論理否定(1の補数)       | 右 
sizeof(), (TYPE)      | サイズ、キャスト       | 右 
.      | 参照       | 左 
*, /, %     | 乗算、除算、余剰       | 左 
+, -      | 加算、減算       | 左 
<<,>>      | 整数左シフト、整数右シフト       | 左 
<, >, <=, >=      | 小さい、大きい、小さいか等しい、大きいか等しい       | 左 
==, !=      | 等しい 等しくない       | 左 
&, "|", ^      | ビットごとの論理積,ビットごとの排他的論理和,ビットごとの論理和       | 左 
&&, "||"     | 論理積(AND),論理和(OR)       | 左 
?:      | 単純代入、乗算代入、除算代入、剰余代入、加算代入、減算代入、ビットごとの論理積代入、ビットごとの論理和代入、ビットごとの排他的論理和       | 
=, =, /=, %=, +=, -=, <<=, >>=, &=, |=, ^=      | 三項演算子       | 右 

## 実行文

- | -
---------- | ----------
実行      | 
分岐      | if, if-elesやswitch-case
繰り返し その1      | whileやfor
繰り返し その2      | do-while

[[Embed(2-1.png, caption=図2-1 プログラムの実行手順)]]

### if
条件式が成立したときに処理すべき文を指定するif文は、次の形式で記述します。

```
if(条件式)
    条件式が成立したときに処理すべき文
```
ただし、複数の文を指定する場合は、ブロックを使います。

```
if(条件式)
{
    条件式が成立したときに処理すべき文
    条件式が成立したときに処理すべき文
}
```
また、条件式の評価結果に従って、いずれかの文の実行を指定する場合は、直後にelse文を付加した次の形式を使います。

```
if(条件式)
    条件式が成立したときに処理すべき文
else
    条件式が不成立したときに処理すべき文
```
この形式でも、複数の文を指定する場合は、ブロックを使います。

```
if(条件式)
{
　　条件式が成立したときに処理すべき文
}else{
　　条件式が不成立したときに処理すべき文
}
```
### switch
switch文は整数定数式が記述されているcase文の位置に分岐して、その位置から文を実行します。caseで指定されている整数に同じものがあった場合はより上に書かれているcaseが実行されます。 また、一致するcaseが無かった場合default文があればdefault文以降から実行します。無い場合はswitch文を終了します。

```
switch(数式)
{
　　case 整数定数式:
　　　　数式と整数定数式が一致したときに処理すべき文
　　case 整数定数式:
　　　　数式と整数定数式が一致したときに処理すべき文
　　default:
　　　　一致しないときに処理すべき文
}
```
注意すべき点があります。分岐後はbreak文が見付かるまでcase文やdefault文を無視します。

```
switch(数式){
　　case 整数定数式:
　　　　数式と整数定数式が一致したときに処理すべき文
　　　　break;
　　case 整数定数式:
　　case 整数定数式:
　　　　数式と整数定数式が一致したときに処理すべき文
　　　　break;
　　default:
　　　　一致しないときに処理すべき文
　　　　break;
}
```
### while
条件式は繰り返し部分の実行前に評価され、成立しなければwhile文を終了します。条件式が成立すると繰り返し部分が処理され、再び条件式が評価されます。

```
while(条件式)
　　条件が成立したときに処理すべき文

while(条件式)
{
　　条件が成立したときに処理すべき文
}
```
### do
do文は繰り返し処理碁に条件式を評価します。

```
do {
　　繰り返し処理
}while(条件式);
```
while文の評価をループの最後で評価するようにしたものが、do文です。do文とwhile文の違いは二点です。while文はループの先頭で評価を行い、do文はループの最後で評価します。 while文は条件式が成立している間実行され、do文は条件式が成立すると終了します。

### for
繰り返し処理を行うのがfor文です。

```
for初期化式 ; 条件式 ;演算式)
　　繰り返し処理する文

for(初期化式 ; 条件式 ;演算式)
{
　　繰り返し処理する文
}
```
初期化式は最初に一度だけ実行される文です。条件式はループ実行前に評価され、成立しなければfor文を終了します。また成立した場合、ループの最後に演算式が実行されます。

### break
break文は、この文を含む最も内側のdo,for,whileまたはswitch文から抜け出る。

### continue
continue文は、この文を含む最も内側のdo,forまたはwhile文で残りの文を飛ばして次の処理に移ります。

### goto

```
actor Luyue
{
    action main
    {
        if(flag == TRUE)
            goto ABORT;
        setAnime(KICK);
        setMessage("I hate you!");
ABORT:
    }
}
```
### request
自分を含めたアクターにリクエストします。リクエスト先が同レベルのリクエストを実行または予約されていた場合はそのリクエストは無効になります。

request(Priority, ActorRef->ActionName);
Priority …　プライオリティ
ActorRef　…　アクター名
ActionName … アクション名

```
actor Mom
{
    action main
    {
        request(8, Kid->cleaning);
    }
}
actor Kid
{
    action cleaning
    {
        setAnimation(CLEANING);
    }
}
```
###return
action内では現在のアクションからより低いリクエストのタグへ復帰します。Function内では呼び出し元に戻ります。

```
void function(int count, string name)
{
    return;
}
int function_value(int count, string name)
{
    return 2;
}
actor Dad
{
    action talk
    {
        if(sender != Mom)
            return;
        setAnimation(SLEEPING);
    }
}
```
### rollback
指定の優先順位未満のアクションまで戻ります。

```
actor Kid
{
    action main
    {
        request(5, Kid->sleep);
    }
    action sleep
    {
    }
    action work
    {
    }
    action talk
    {
        if(sender == Boss)
        {
            rollback 4;             // cancel sleeping action
            request(5, Kid->work); // request working action
        }
    }
}
```
### join
アクターの優先度が指定レベル以下になるまで待ちます。

```
actor Boss
{
    action order
    {
        request(1, Employee->doWork);
        join(1, Employee);  // 仕事が終了するまで待つ
    }
}
```
