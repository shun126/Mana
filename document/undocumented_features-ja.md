# 実装に基づく補足リファレンス（未明文化機能）

本ドキュメントは、Mana の実装から読み取れる挙動を整理した補足資料です。新しい仕様の追加や挙動変更は行いません。実装から直接読み取れない点は **未定義／実装依存** として明記します。

## native 関数

### 概要（目的・役割）
- `native` で宣言された関数は、Mana スクリプトから VM を経由して C++ 側の外部関数を呼び出すための入口です。
- 実体（本体）は Mana スクリプト内には存在せず、VM 側で登録された外部関数に名前で接続されます。

### Mana スクリプト側での宣言方法
- 宣言は `native` キーワード付きの関数プロトタイプのみで、**本文（ブロック）は持ちません**。
- グローバル宣言と、`struct` 内のメンバー宣言の両方が許可されています。

```mana
native void waitFrame(int frame);

struct Foo
{
    native int bar(int x);
}
```

### 実行時の流れ（Mana → VM → C++）
1. コンパイル時に `native` 宣言は「ネイティブ関数」として登録され、呼び出しは `Call` 命令になります。
2. 実行時、VM は `Call` 命令で関数名（文字列）から外部関数を検索し、見つかった場合は登録済みの C++ 関数を実行します。
3. 引数は VM のスタックに積まれており、外部関数は `Actor` から引数を取得します。戻り値は `Actor::SetReturn*` 系 API を使って設定され、VM がスタックへ戻します。

### 通常の Mana 関数との違い
- Mana 関数はコンパイル済みのバイトコードへ直接分岐しますが、native 関数は **関数名（文字列）で外部関数を検索して呼び出す** という経路になります。
- native 関数は本文を持たず、宣言のみです。
- `struct` のメンバーとして宣言された native 関数は、実行時に `"Struct名::関数名"` という外部名で解決されます（`this` 相当のポインタも渡されます）。

### 制約事項・注意点
- 引数の**個数一致**はチェックされますが、引数型の安全性は C++ 側の実装に依存します（型不整合時の挙動は実装依存）。
- 外部関数が見つからない場合、VM はエラーログを出力します。戻り値が必要な呼び出しだった場合は実行が強制終了されます（`void` であれば継続）。
- `native` 宣言は深いブロック内（関数内など）で行うとエラーになります（プロトタイプ宣言は無視される扱い）。
- 不完全型（`incomplete`）は native 関数の戻り値として使用できません。

### 未定義・実装依存
- 引数の型変換・型安全性、C++ 側の例外やエラー処理の伝播は仕様として定義されていません（実装依存）。
- 外部関数の登録方式（プラグインなど）の運用ルールは、このドキュメントの範囲では未定義です。

## namespace / using

### namespace の役割
- `namespace` は **名前空間の階層を構築してシンボル名を分離** するための仕組みです。
- 名前空間はセマンティック解析で登録され、解決時に `A::B::C` のような修飾名として扱われます。

### using 構文の基本的な意味
- `using` は、**別名前空間のシンボルを現在の解決スコープへ追加** する宣言です。
- `using` はセマンティック解析中に解決され、現在の namespace スコープに対して有効になります（ネストした namespace では内側が優先）。

### `using N;` と `using A::B;` の違い
- `using N;`
  - `N` を「名前空間として」探索対象に追加します。
  - 以後、未修飾名の解決で `N::X` が候補になります。
- `using A::B;`
  - `A::B` が名前空間であれば、`A::B` を探索対象に追加します。
  - `A::B` が **actor / module シンボル** の場合は、`B` を **エイリアス** として登録し、`B` を未修飾名として参照可能にします。
  - `A::B` が名前空間でも actor/module でもない場合、`unresolved using` エラーになります。

### 名前解決が行われるタイミング（セマンティック解析）
- 名前解決は **パース後のセマンティック解析** で行われます。
- そのため、`using` や `namespace` の前方参照が可能です。

### 前方参照が可能である理由
- Mana は複数のソースを 1 コンパイルユニットとして扱い、パース後に全体をセマンティック解析します。
- 解析過程で名前空間が登録されるため、**後から定義される namespace も using で参照可能** です。

### 名前解決に失敗した場合の扱い
- `using` の解決が曖昧な場合は **`ambiguous using` エラー** になります。
- `using` の解決に失敗した場合は **`unresolved using` エラー** になります。
- 参照候補が複数ある場合、**`ambiguous symbol/type/actor reference` エラー** になります。

### 未定義・制限されている点
- `using` が解決対象とするのは **名前空間** と **actor/module シンボル** に限定されています。その他の型や関数に対する `using` の挙動は定義されていません。
- `using` の衝突解消ルール（優先順位の明確な仕様）は実装依存です（現状は内側スコープ優先）。

## actor と phantom の違い

### それぞれの概念
- `actor` は **VM 起動時にインスタンスが生成され、実行対象になるアクター** です。
- `phantom` は **アクター定義のテンプレート** であり、VM 起動時に自動生成されません。

### 役割・用途の違い
- `actor` は通常の実行対象として `init` / `main` などが起動されます。
- `phantom` は C++ 側から明示的に生成するための素材として扱われます。

### 定義方法・使用方法の違い
- 定義は `actor` / `phantom` それぞれのキーワードで行います（構文は同一）。
- `phantom` は VM のロード時にインスタンス化されないため、スクリプト単体では実行されません。

### 実行時（VM 上）での扱いの違い
- VM はロード時に `actor` を即時インスタンス化し、アクター一覧に登録します。
- `phantom` は **名前とアクション情報のみを保持** し、C++ 側の `CreateActorFromPhantom` が呼ばれた時点で初めてインスタンス化されます。

### なぜ 2 つの概念が分かれているのか（設計意図）
- 実装上、`phantom` は **事前に登録されたアクター定義を複製するためのテンプレート** として扱われています。
- これにより、実行時に必要なタイミングでアクターを生成できます。

### どちらを使うべきかの指針
- 起動時に常駐・初期化されるアクターが必要なら `actor` を使用します。
- C++ 側から動的に生成したいアクター定義が必要なら `phantom` を使用します。

### 未定義・将来拡張予定の点
- `phantom` の生成・破棄ルールやライフサイクル管理は C++ 側の実装に依存します。
- スクリプト側から `phantom` を直接生成する手段は仕様として定義されていません。
