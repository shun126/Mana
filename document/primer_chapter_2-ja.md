## 第２章 プログラムの構造
## actorとaction
ManaはActorブロック一つがゲーム中のキャラクター一人に一対一で対応します。
つまり、ソース中にActorブロックが一つも存在しない場合、ゲーム中にはキャラクターが存在しないことになります。
Actorブロック内にはActionブロックが置かれ、そのキャラクターの行動を記述することでキャラクターの行動を定義することができます。
アクション内の文は必ず;で終わるか{}で囲まれていなければなりません。
{}で囲まれた部分をブロックと呼び、処理を一まとめとして扱うことができます。

## 誰が私を呼んだのか？
actionブロック内のローカル変数senderには呼び出したアクターの情報が入っています。そこでsenderを利用する事によりリクエストを受けた相手によって行動を変更する事が出来ます。

### senderの利用方法

```
actor GoodLookingGuy
{
}

actor Girl
{
    action talk
    {
        switch(sender)
        {
        case GoodLookingGuy:
            setMessage("Hello, nice to meet you.");
            break;
    
        default:
            setMessage("...");
            break;
        }
    }
}
```

## 同期と非同期
さて、以前述べたようにManaは擬似並列処理を制御しやすくする為に作られた言語ですが、アクターによってはある一定の処理が終わるまで処理を中断して欲しくない状態があると思います。

例えば全体のアニメーションを管理しているアクターなどは全体のアニメーションの指示の途中でフレームが切り替わると各アクターの同期が取れない等のことが考えられます。
そこで、勝手にアクターの処理が切り替わっては困る期間をlockというブロックでその間はyield()命令が発行されるまで処理を他のアクターへ切り替えません。

### 同期アクターの作成例

```
actor Wife
{
    action talk
    {
        lock
        {
            Punch(Husband);
            Kick(Husband);
            Chop(Husband);
            yield();
        }
    }
}
```

## アクターのアクション
Manaにはアクターをキャラクターに関連付けるだけではなく、空間を定義したオブジェクトと関連付ける事でキャラクターでは実現できないアクションを定義する事が可能です。
例えばボックスを空間内に配置して、“キャラクターが箱を通過する”など様々な条件で割り込みを発生させます。この機能を利用して「道路にボックスを置き、アクターがボックスに入ったら、アクター警備員が注意する」という状況を簡単に作ることができます。

## 関数
関数はactionとは独立した各アクターに共通な処理を外に出すことが出来ます。関数内の文も同様に必ず;で終わるか{}で囲まれていなければなりません。
